// Generated by jextract

package serial.ffm.win;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.util.*;
import java.util.stream.*;

public class Windows {

    Windows() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.findOrThrow(symbol);
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get("bool");
    public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get("char");
    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get("short");
    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get("int");
    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get("long long");
    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get("float");
    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get("double");
    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get("void*"))
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));
    public static final ValueLayout.OfInt C_LONG = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get("long");
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get("double");
    private static final int FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FALSE 0
     * }
     */
    public static int FALSE() {
        return FALSE;
    }
    private static final int TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRUE 1
     * }
     */
    public static int TRUE() {
        return TRUE;
    }
    private static final int FILE_ATTRIBUTE_NORMAL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FILE_ATTRIBUTE_NORMAL 128
     * }
     */
    public static int FILE_ATTRIBUTE_NORMAL() {
        return FILE_ATTRIBUTE_NORMAL;
    }
    private static final int OPEN_EXISTING = (int)3L;
    /**
     * {@snippet lang=c :
     * #define OPEN_EXISTING 3
     * }
     */
    public static int OPEN_EXISTING() {
        return OPEN_EXISTING;
    }
    private static final int FILE_FLAG_OVERLAPPED = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define FILE_FLAG_OVERLAPPED 1073741824
     * }
     */
    public static int FILE_FLAG_OVERLAPPED() {
        return FILE_FLAG_OVERLAPPED;
    }
    private static final int DTR_CONTROL_DISABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define DTR_CONTROL_DISABLE 0
     * }
     */
    public static int DTR_CONTROL_DISABLE() {
        return DTR_CONTROL_DISABLE;
    }
    private static final int RTS_CONTROL_DISABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RTS_CONTROL_DISABLE 0
     * }
     */
    public static int RTS_CONTROL_DISABLE() {
        return RTS_CONTROL_DISABLE;
    }
    private static final int RTS_CONTROL_HANDSHAKE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RTS_CONTROL_HANDSHAKE 2
     * }
     */
    public static int RTS_CONTROL_HANDSHAKE() {
        return RTS_CONTROL_HANDSHAKE;
    }
    private static final int FILE_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FILE_TYPE_UNKNOWN 0
     * }
     */
    public static int FILE_TYPE_UNKNOWN() {
        return FILE_TYPE_UNKNOWN;
    }
    private static final int FILE_TYPE_CHAR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FILE_TYPE_CHAR 2
     * }
     */
    public static int FILE_TYPE_CHAR() {
        return FILE_TYPE_CHAR;
    }
    private static final int NOPARITY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NOPARITY 0
     * }
     */
    public static int NOPARITY() {
        return NOPARITY;
    }
    private static final int ONESTOPBIT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ONESTOPBIT 0
     * }
     */
    public static int ONESTOPBIT() {
        return ONESTOPBIT;
    }
    private static final int TWOSTOPBITS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TWOSTOPBITS 2
     * }
     */
    public static int TWOSTOPBITS() {
        return TWOSTOPBITS;
    }
    private static final int CE_RXOVER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CE_RXOVER 1
     * }
     */
    public static int CE_RXOVER() {
        return CE_RXOVER;
    }
    private static final int CE_OVERRUN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CE_OVERRUN 2
     * }
     */
    public static int CE_OVERRUN() {
        return CE_OVERRUN;
    }
    private static final int CE_RXPARITY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CE_RXPARITY 4
     * }
     */
    public static int CE_RXPARITY() {
        return CE_RXPARITY;
    }
    private static final int CE_FRAME = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CE_FRAME 8
     * }
     */
    public static int CE_FRAME() {
        return CE_FRAME;
    }
    private static final int CE_BREAK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CE_BREAK 16
     * }
     */
    public static int CE_BREAK() {
        return CE_BREAK;
    }
    private static final int EV_RXCHAR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EV_RXCHAR 1
     * }
     */
    public static int EV_RXCHAR() {
        return EV_RXCHAR;
    }
    private static final int EV_RXFLAG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EV_RXFLAG 2
     * }
     */
    public static int EV_RXFLAG() {
        return EV_RXFLAG;
    }
    private static final int EV_CTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EV_CTS 8
     * }
     */
    public static int EV_CTS() {
        return EV_CTS;
    }
    private static final int EV_DSR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EV_DSR 16
     * }
     */
    public static int EV_DSR() {
        return EV_DSR;
    }
    private static final int EV_RLSD = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EV_RLSD 32
     * }
     */
    public static int EV_RLSD() {
        return EV_RLSD;
    }
    private static final int EV_BREAK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EV_BREAK 64
     * }
     */
    public static int EV_BREAK() {
        return EV_BREAK;
    }
    private static final int EV_ERR = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EV_ERR 128
     * }
     */
    public static int EV_ERR() {
        return EV_ERR;
    }
    private static final int EV_RING = (int)256L;
    /**
     * {@snippet lang=c :
     * #define EV_RING 256
     * }
     */
    public static int EV_RING() {
        return EV_RING;
    }
    private static final int SETDTR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SETDTR 5
     * }
     */
    public static int SETDTR() {
        return SETDTR;
    }
    private static final int FORMAT_MESSAGE_IGNORE_INSERTS = (int)512L;
    /**
     * {@snippet lang=c :
     * #define FORMAT_MESSAGE_IGNORE_INSERTS 512
     * }
     */
    public static int FORMAT_MESSAGE_IGNORE_INSERTS() {
        return FORMAT_MESSAGE_IGNORE_INSERTS;
    }
    private static final int FORMAT_MESSAGE_FROM_SYSTEM = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FORMAT_MESSAGE_FROM_SYSTEM 4096
     * }
     */
    public static int FORMAT_MESSAGE_FROM_SYSTEM() {
        return FORMAT_MESSAGE_FROM_SYSTEM;
    }
    private static final int FORMAT_MESSAGE_MAX_WIDTH_MASK = (int)255L;
    /**
     * {@snippet lang=c :
     * #define FORMAT_MESSAGE_MAX_WIDTH_MASK 255
     * }
     */
    public static int FORMAT_MESSAGE_MAX_WIDTH_MASK() {
        return FORMAT_MESSAGE_MAX_WIDTH_MASK;
    }

    private static class CreateFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_LONG,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("CreateFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileA$descriptor() {
        return CreateFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileA$handle() {
        return CreateFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileA$address() {
        return CreateFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileA", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushFileBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("FlushFileBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor FlushFileBuffers$descriptor() {
        return FlushFileBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static MethodHandle FlushFileBuffers$handle() {
        return FlushFileBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static MemorySegment FlushFileBuffers$address() {
        return FlushFileBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static int FlushFileBuffers(MemorySegment hFile) {
        var mh$ = FlushFileBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushFileBuffers", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_LONG,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("GetFileType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor GetFileType$descriptor() {
        return GetFileType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MethodHandle GetFileType$handle() {
        return GetFileType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MemorySegment GetFileType$address() {
        return GetFileType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static int GetFileType(MemorySegment hFile) {
        var mh$ = GetFileType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileType", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("ReadFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFile$descriptor() {
        return ReadFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFile$handle() {
        return ReadFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ReadFile$address() {
        return ReadFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, MemorySegment lpOverlapped) {
        var mh$ = ReadFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFile", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("WriteFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFile$descriptor() {
        return WriteFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFile$handle() {
        return WriteFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WriteFile$address() {
        return WriteFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, MemorySegment lpOverlapped) {
        var mh$ = WriteFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFile", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("CloseHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static FunctionDescriptor CloseHandle$descriptor() {
        return CloseHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MethodHandle CloseHandle$handle() {
        return CloseHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MemorySegment CloseHandle$address() {
        return CloseHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static int CloseHandle(MemorySegment hObject) {
        var mh$ = CloseHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseHandle", hObject);
            }
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_LONG    );

        public static final MemorySegment ADDR = Windows.findOrThrow("GetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLastError(void)
     * }
     */
    public static FunctionDescriptor GetLastError$descriptor() {
        return GetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLastError(void)
     * }
     */
    public static MethodHandle GetLastError$handle() {
        return GetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLastError(void)
     * }
     */
    public static MemorySegment GetLastError$address() {
        return GetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLastError(void)
     * }
     */
    public static int GetLastError() {
        var mh$ = GetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_INT
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("GetOverlappedResult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static FunctionDescriptor GetOverlappedResult$descriptor() {
        return GetOverlappedResult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MethodHandle GetOverlappedResult$handle() {
        return GetOverlappedResult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MemorySegment GetOverlappedResult$address() {
        return GetOverlappedResult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static int GetOverlappedResult(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int bWait) {
        var mh$ = GetOverlappedResult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResult", hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_LONG
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("WaitForSingleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForSingleObject$descriptor() {
        return WaitForSingleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForSingleObject$handle() {
        return WaitForSingleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForSingleObject$address() {
        return WaitForSingleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForSingleObject(MemorySegment hHandle, int dwMilliseconds) {
        var mh$ = WaitForSingleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObject", hHandle, dwMilliseconds);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_INT,
            Windows.C_INT,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("CreateEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventA$descriptor() {
        return CreateEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateEventA$handle() {
        return CreateEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA$address() {
        return CreateEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventA", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearCommError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("ClearCommError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static FunctionDescriptor ClearCommError$descriptor() {
        return ClearCommError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static MethodHandle ClearCommError$handle() {
        return ClearCommError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static MemorySegment ClearCommError$address() {
        return ClearCommError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static int ClearCommError(MemorySegment hFile, MemorySegment lpErrors, MemorySegment lpStat) {
        var mh$ = ClearCommError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearCommError", hFile, lpErrors, lpStat);
            }
            return (int)mh$.invokeExact(hFile, lpErrors, lpStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetupComm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_LONG
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("SetupComm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static FunctionDescriptor SetupComm$descriptor() {
        return SetupComm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static MethodHandle SetupComm$handle() {
        return SetupComm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static MemorySegment SetupComm$address() {
        return SetupComm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static int SetupComm(MemorySegment hFile, int dwInQueue, int dwOutQueue) {
        var mh$ = SetupComm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetupComm", hFile, dwInQueue, dwOutQueue);
            }
            return (int)mh$.invokeExact(hFile, dwInQueue, dwOutQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EscapeCommFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_LONG
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("EscapeCommFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static FunctionDescriptor EscapeCommFunction$descriptor() {
        return EscapeCommFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static MethodHandle EscapeCommFunction$handle() {
        return EscapeCommFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static MemorySegment EscapeCommFunction$address() {
        return EscapeCommFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static int EscapeCommFunction(MemorySegment hFile, int dwFunc) {
        var mh$ = EscapeCommFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EscapeCommFunction", hFile, dwFunc);
            }
            return (int)mh$.invokeExact(hFile, dwFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("GetCommMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static FunctionDescriptor GetCommMask$descriptor() {
        return GetCommMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static MethodHandle GetCommMask$handle() {
        return GetCommMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static MemorySegment GetCommMask$address() {
        return GetCommMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static int GetCommMask(MemorySegment hFile, MemorySegment lpEvtMask) {
        var mh$ = GetCommMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommMask", hFile, lpEvtMask);
            }
            return (int)mh$.invokeExact(hFile, lpEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("GetCommProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static FunctionDescriptor GetCommProperties$descriptor() {
        return GetCommProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static MethodHandle GetCommProperties$handle() {
        return GetCommProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static MemorySegment GetCommProperties$address() {
        return GetCommProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static int GetCommProperties(MemorySegment hFile, MemorySegment lpCommProp) {
        var mh$ = GetCommProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommProperties", hFile, lpCommProp);
            }
            return (int)mh$.invokeExact(hFile, lpCommProp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommModemStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("GetCommModemStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static FunctionDescriptor GetCommModemStatus$descriptor() {
        return GetCommModemStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static MethodHandle GetCommModemStatus$handle() {
        return GetCommModemStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static MemorySegment GetCommModemStatus$address() {
        return GetCommModemStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static int GetCommModemStatus(MemorySegment hFile, MemorySegment lpModemStat) {
        var mh$ = GetCommModemStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommModemStatus", hFile, lpModemStat);
            }
            return (int)mh$.invokeExact(hFile, lpModemStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("GetCommState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor GetCommState$descriptor() {
        return GetCommState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MethodHandle GetCommState$handle() {
        return GetCommState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MemorySegment GetCommState$address() {
        return GetCommState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int GetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = GetCommState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommState", hFile, lpDCB);
            }
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommTimeouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("GetCommTimeouts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor GetCommTimeouts$descriptor() {
        return GetCommTimeouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle GetCommTimeouts$handle() {
        return GetCommTimeouts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment GetCommTimeouts$address() {
        return GetCommTimeouts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int GetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = GetCommTimeouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_LONG
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("SetCommMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static FunctionDescriptor SetCommMask$descriptor() {
        return SetCommMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static MethodHandle SetCommMask$handle() {
        return SetCommMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static MemorySegment SetCommMask$address() {
        return SetCommMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static int SetCommMask(MemorySegment hFile, int dwEvtMask) {
        var mh$ = SetCommMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommMask", hFile, dwEvtMask);
            }
            return (int)mh$.invokeExact(hFile, dwEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("SetCommState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor SetCommState$descriptor() {
        return SetCommState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MethodHandle SetCommState$handle() {
        return SetCommState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MemorySegment SetCommState$address() {
        return SetCommState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int SetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = SetCommState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommState", hFile, lpDCB);
            }
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommTimeouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("SetCommTimeouts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor SetCommTimeouts$descriptor() {
        return SetCommTimeouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle SetCommTimeouts$handle() {
        return SetCommTimeouts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment SetCommTimeouts$address() {
        return SetCommTimeouts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int SetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = SetCommTimeouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitCommEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_INT,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("WaitCommEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WaitCommEvent$descriptor() {
        return WaitCommEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WaitCommEvent$handle() {
        return WaitCommEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WaitCommEvent$address() {
        return WaitCommEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WaitCommEvent(MemorySegment hFile, MemorySegment lpEvtMask, MemorySegment lpOverlapped) {
        var mh$ = WaitCommEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitCommEvent", hFile, lpEvtMask, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpEvtMask, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FormatMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_LONG,
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("FormatMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static FunctionDescriptor FormatMessageA$descriptor() {
        return FormatMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MethodHandle FormatMessageA$handle() {
        return FormatMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MemorySegment FormatMessageA$address() {
        return FormatMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static int FormatMessageA(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatMessageA", dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
            }
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCloseKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_LONG,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("RegCloseKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static FunctionDescriptor RegCloseKey$descriptor() {
        return RegCloseKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MethodHandle RegCloseKey$handle() {
        return RegCloseKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MemorySegment RegCloseKey$address() {
        return RegCloseKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static int RegCloseKey(MemorySegment hKey) {
        var mh$ = RegCloseKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCloseKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("RegEnumValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegEnumValueA$descriptor() {
        return RegEnumValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegEnumValueA$handle() {
        return RegEnumValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegEnumValueA$address() {
        return RegEnumValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegEnumValueA(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumValueA", hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Windows.C_LONG,
            Windows.C_POINTER,
            Windows.C_POINTER,
            Windows.C_LONG,
            Windows.C_LONG,
            Windows.C_POINTER
        );

        public static final MemorySegment ADDR = Windows.findOrThrow("RegOpenKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyExA$descriptor() {
        return RegOpenKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyExA$handle() {
        return RegOpenKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyExA$address() {
        return RegOpenKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyExA", hKey, lpSubKey, ulOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int GENERIC_READ = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define GENERIC_READ 2147483648
     * }
     */
    public static int GENERIC_READ() {
        return GENERIC_READ;
    }
    private static final int GENERIC_WRITE = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define GENERIC_WRITE 1073741824
     * }
     */
    public static int GENERIC_WRITE() {
        return GENERIC_WRITE;
    }
    private static final int KEY_READ = (int)131097L;
    /**
     * {@snippet lang=c :
     * #define KEY_READ 131097
     * }
     */
    public static int KEY_READ() {
        return KEY_READ;
    }
    private static final MemorySegment INVALID_HANDLE_VALUE = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define INVALID_HANDLE_VALUE (void*) -1
     * }
     */
    public static MemorySegment INVALID_HANDLE_VALUE() {
        return INVALID_HANDLE_VALUE;
    }
    private static final int WAIT_OBJECT_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WAIT_OBJECT_0 0
     * }
     */
    public static int WAIT_OBJECT_0() {
        return WAIT_OBJECT_0;
    }
    private static final int INFINITE = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define INFINITE 4294967295
     * }
     */
    public static int INFINITE() {
        return INFINITE;
    }
    private static final int ERROR_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ERROR_SUCCESS 0
     * }
     */
    public static int ERROR_SUCCESS() {
        return ERROR_SUCCESS;
    }
    private static final int NO_ERROR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NO_ERROR 0
     * }
     */
    public static int NO_ERROR() {
        return NO_ERROR;
    }
    private static final int ERROR_FILE_NOT_FOUND = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ERROR_FILE_NOT_FOUND 2
     * }
     */
    public static int ERROR_FILE_NOT_FOUND() {
        return ERROR_FILE_NOT_FOUND;
    }
    private static final int ERROR_PATH_NOT_FOUND = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ERROR_PATH_NOT_FOUND 3
     * }
     */
    public static int ERROR_PATH_NOT_FOUND() {
        return ERROR_PATH_NOT_FOUND;
    }
    private static final int ERROR_NO_MORE_ITEMS = (int)259L;
    /**
     * {@snippet lang=c :
     * #define ERROR_NO_MORE_ITEMS 259
     * }
     */
    public static int ERROR_NO_MORE_ITEMS() {
        return ERROR_NO_MORE_ITEMS;
    }
    private static final int ERROR_IO_PENDING = (int)997L;
    /**
     * {@snippet lang=c :
     * #define ERROR_IO_PENDING 997
     * }
     */
    public static int ERROR_IO_PENDING() {
        return ERROR_IO_PENDING;
    }
    private static final MemorySegment HKEY_LOCAL_MACHINE = MemorySegment.ofAddress(-2147483646L);
    /**
     * {@snippet lang=c :
     * #define HKEY_LOCAL_MACHINE (void*) -2147483646
     * }
     */
    public static MemorySegment HKEY_LOCAL_MACHINE() {
        return HKEY_LOCAL_MACHINE;
    }
}

