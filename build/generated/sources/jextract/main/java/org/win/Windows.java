// Generated by jextract

package org.win;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Windows {

    static final SymbolLookup SYMBOL_LOOKUP
            = SymbolLookup.loaderLookup().or(Linker.nativeLinker().defaultLookup());

    Windows() {
        // Suppresses public default constructor, ensuring non-instantiability,
        // but allows generated subclasses in same package.
    }

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;

    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MemoryLayout[] inferVariadicLayouts(Object[] varargs) {
        MemoryLayout[] result = new MemoryLayout[varargs.length];
        for (int i = 0; i < varargs.length; i++) {
            result[i] = variadicLayout(varargs[i].getClass());
        }
        return result;
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MethodHandle downcallHandleVariadic(String name, FunctionDescriptor baseDesc, MemoryLayout[] variadicLayouts) {
        FunctionDescriptor variadicDesc = baseDesc.appendArgumentLayouts(variadicLayouts);
        Linker.Option fva = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());
        return SYMBOL_LOOKUP.find(name)
                .map(addr -> Linker.nativeLinker().downcallHandle(addr, variadicDesc, fva)
                        .asSpreader(Object[].class, variadicLayouts.length))
                .orElse(null);
    }

    // Internals only below this point

    private static MemoryLayout variadicLayout(Class<?> c) {
        // apply default argument promotions per C spec
        // note that all primitives are boxed, since they are passed through an Object[]
        if (c == Boolean.class || c == Byte.class || c == Character.class || c == Short.class || c == Integer.class) {
            return JAVA_INT;
        } else if (c == Long.class) {
            return JAVA_LONG;
        } else if (c == Float.class || c == Double.class) {
            return JAVA_DOUBLE;
        } else if (MemorySegment.class.isAssignableFrom(c)) {
            return ADDRESS;
        }
        throw new IllegalArgumentException("Invalid type for ABI: " + c.getTypeName());
    }
    private static final int FALSE = (int)0L;

    /**
     * {@snippet lang=c :
     * #define FALSE 0
     * }
     */
    public static int FALSE() {
        return FALSE;
    }
    private static final int TRUE = (int)1L;

    /**
     * {@snippet lang=c :
     * #define TRUE 1
     * }
     */
    public static int TRUE() {
        return TRUE;
    }
    private static final int FILE_ATTRIBUTE_NORMAL = (int)128L;

    /**
     * {@snippet lang=c :
     * #define FILE_ATTRIBUTE_NORMAL 128
     * }
     */
    public static int FILE_ATTRIBUTE_NORMAL() {
        return FILE_ATTRIBUTE_NORMAL;
    }
    private static final int OPEN_EXISTING = (int)3L;

    /**
     * {@snippet lang=c :
     * #define OPEN_EXISTING 3
     * }
     */
    public static int OPEN_EXISTING() {
        return OPEN_EXISTING;
    }
    private static final int FILE_FLAG_OVERLAPPED = (int)1073741824L;

    /**
     * {@snippet lang=c :
     * #define FILE_FLAG_OVERLAPPED 1073741824
     * }
     */
    public static int FILE_FLAG_OVERLAPPED() {
        return FILE_FLAG_OVERLAPPED;
    }
    private static final int DTR_CONTROL_DISABLE = (int)0L;

    /**
     * {@snippet lang=c :
     * #define DTR_CONTROL_DISABLE 0
     * }
     */
    public static int DTR_CONTROL_DISABLE() {
        return DTR_CONTROL_DISABLE;
    }
    private static final int RTS_CONTROL_DISABLE = (int)0L;

    /**
     * {@snippet lang=c :
     * #define RTS_CONTROL_DISABLE 0
     * }
     */
    public static int RTS_CONTROL_DISABLE() {
        return RTS_CONTROL_DISABLE;
    }
    private static final int RTS_CONTROL_HANDSHAKE = (int)2L;

    /**
     * {@snippet lang=c :
     * #define RTS_CONTROL_HANDSHAKE 2
     * }
     */
    public static int RTS_CONTROL_HANDSHAKE() {
        return RTS_CONTROL_HANDSHAKE;
    }
    private static final int FILE_TYPE_UNKNOWN = (int)0L;

    /**
     * {@snippet lang=c :
     * #define FILE_TYPE_UNKNOWN 0
     * }
     */
    public static int FILE_TYPE_UNKNOWN() {
        return FILE_TYPE_UNKNOWN;
    }
    private static final int FILE_TYPE_CHAR = (int)2L;

    /**
     * {@snippet lang=c :
     * #define FILE_TYPE_CHAR 2
     * }
     */
    public static int FILE_TYPE_CHAR() {
        return FILE_TYPE_CHAR;
    }
    private static final int NOPARITY = (int)0L;

    /**
     * {@snippet lang=c :
     * #define NOPARITY 0
     * }
     */
    public static int NOPARITY() {
        return NOPARITY;
    }
    private static final int ONESTOPBIT = (int)0L;

    /**
     * {@snippet lang=c :
     * #define ONESTOPBIT 0
     * }
     */
    public static int ONESTOPBIT() {
        return ONESTOPBIT;
    }
    private static final int TWOSTOPBITS = (int)2L;

    /**
     * {@snippet lang=c :
     * #define TWOSTOPBITS 2
     * }
     */
    public static int TWOSTOPBITS() {
        return TWOSTOPBITS;
    }
    private static final int CE_RXOVER = (int)1L;

    /**
     * {@snippet lang=c :
     * #define CE_RXOVER 1
     * }
     */
    public static int CE_RXOVER() {
        return CE_RXOVER;
    }
    private static final int CE_OVERRUN = (int)2L;

    /**
     * {@snippet lang=c :
     * #define CE_OVERRUN 2
     * }
     */
    public static int CE_OVERRUN() {
        return CE_OVERRUN;
    }
    private static final int CE_RXPARITY = (int)4L;

    /**
     * {@snippet lang=c :
     * #define CE_RXPARITY 4
     * }
     */
    public static int CE_RXPARITY() {
        return CE_RXPARITY;
    }
    private static final int CE_FRAME = (int)8L;

    /**
     * {@snippet lang=c :
     * #define CE_FRAME 8
     * }
     */
    public static int CE_FRAME() {
        return CE_FRAME;
    }
    private static final int CE_BREAK = (int)16L;

    /**
     * {@snippet lang=c :
     * #define CE_BREAK 16
     * }
     */
    public static int CE_BREAK() {
        return CE_BREAK;
    }
    private static final int EV_RXCHAR = (int)1L;

    /**
     * {@snippet lang=c :
     * #define EV_RXCHAR 1
     * }
     */
    public static int EV_RXCHAR() {
        return EV_RXCHAR;
    }
    private static final int EV_RXFLAG = (int)2L;

    /**
     * {@snippet lang=c :
     * #define EV_RXFLAG 2
     * }
     */
    public static int EV_RXFLAG() {
        return EV_RXFLAG;
    }
    private static final int EV_CTS = (int)8L;

    /**
     * {@snippet lang=c :
     * #define EV_CTS 8
     * }
     */
    public static int EV_CTS() {
        return EV_CTS;
    }
    private static final int EV_DSR = (int)16L;

    /**
     * {@snippet lang=c :
     * #define EV_DSR 16
     * }
     */
    public static int EV_DSR() {
        return EV_DSR;
    }
    private static final int EV_RLSD = (int)32L;

    /**
     * {@snippet lang=c :
     * #define EV_RLSD 32
     * }
     */
    public static int EV_RLSD() {
        return EV_RLSD;
    }
    private static final int EV_BREAK = (int)64L;

    /**
     * {@snippet lang=c :
     * #define EV_BREAK 64
     * }
     */
    public static int EV_BREAK() {
        return EV_BREAK;
    }
    private static final int EV_ERR = (int)128L;

    /**
     * {@snippet lang=c :
     * #define EV_ERR 128
     * }
     */
    public static int EV_ERR() {
        return EV_ERR;
    }
    private static final int EV_RING = (int)256L;

    /**
     * {@snippet lang=c :
     * #define EV_RING 256
     * }
     */
    public static int EV_RING() {
        return EV_RING;
    }
    private static final int SETDTR = (int)5L;

    /**
     * {@snippet lang=c :
     * #define SETDTR 5
     * }
     */
    public static int SETDTR() {
        return SETDTR;
    }
    private static final int FORMAT_MESSAGE_IGNORE_INSERTS = (int)512L;

    /**
     * {@snippet lang=c :
     * #define FORMAT_MESSAGE_IGNORE_INSERTS 512
     * }
     */
    public static int FORMAT_MESSAGE_IGNORE_INSERTS() {
        return FORMAT_MESSAGE_IGNORE_INSERTS;
    }
    private static final int FORMAT_MESSAGE_FROM_SYSTEM = (int)4096L;

    /**
     * {@snippet lang=c :
     * #define FORMAT_MESSAGE_FROM_SYSTEM 4096
     * }
     */
    public static int FORMAT_MESSAGE_FROM_SYSTEM() {
        return FORMAT_MESSAGE_FROM_SYSTEM;
    }
    private static final int FORMAT_MESSAGE_MAX_WIDTH_MASK = (int)255L;

    /**
     * {@snippet lang=c :
     * #define FORMAT_MESSAGE_MAX_WIDTH_MASK 255
     * }
     */
    public static int FORMAT_MESSAGE_MAX_WIDTH_MASK() {
        return FORMAT_MESSAGE_MAX_WIDTH_MASK;
    }

    public static MethodHandle CreateFileA$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_LONG,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("CreateFileA"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileA$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileA", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment) mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle FlushFileBuffers$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("FlushFileBuffers"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static int FlushFileBuffers(MemorySegment hFile) {
        var mh$ = FlushFileBuffers$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushFileBuffers", hFile);
            }
            return (int) mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle GetFileType$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_LONG,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("GetFileType"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static int GetFileType(MemorySegment hFile) {
        var mh$ = GetFileType$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileType", hFile);
            }
            return (int) mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle ReadFile$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("ReadFile"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, MemorySegment lpOverlapped) {
        var mh$ = ReadFile$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFile", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
            }
            return (int) mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle WriteFile$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("WriteFile"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, MemorySegment lpOverlapped) {
        var mh$ = WriteFile$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFile", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
            }
            return (int) mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle CloseHandle$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("CloseHandle"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static int CloseHandle(MemorySegment hObject) {
        var mh$ = CloseHandle$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseHandle", hObject);
            }
            return (int) mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle GetLastError$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_LONG        );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("GetLastError"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLastError(void)
     * }
     */
    public static int GetLastError() {
        var mh$ = GetLastError$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastError");
            }
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle GetOverlappedResult$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_INT
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("GetOverlappedResult"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static int GetOverlappedResult(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int bWait) {
        var mh$ = GetOverlappedResult$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResult", hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
            }
            return (int) mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle WaitForSingleObject$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_LONG
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("WaitForSingleObject"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForSingleObject(MemorySegment hHandle, int dwMilliseconds) {
        var mh$ = WaitForSingleObject$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObject", hHandle, dwMilliseconds);
            }
            return (int) mh$.invokeExact(hHandle, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle CreateEventA$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_INT,
                Windows.C_INT,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("CreateEventA"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventA$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventA", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment) mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle ClearCommError$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("ClearCommError"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static int ClearCommError(MemorySegment hFile, MemorySegment lpErrors, MemorySegment lpStat) {
        var mh$ = ClearCommError$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearCommError", hFile, lpErrors, lpStat);
            }
            return (int) mh$.invokeExact(hFile, lpErrors, lpStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle SetupComm$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_LONG
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("SetupComm"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static int SetupComm(MemorySegment hFile, int dwInQueue, int dwOutQueue) {
        var mh$ = SetupComm$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetupComm", hFile, dwInQueue, dwOutQueue);
            }
            return (int) mh$.invokeExact(hFile, dwInQueue, dwOutQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle EscapeCommFunction$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_LONG
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("EscapeCommFunction"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static int EscapeCommFunction(MemorySegment hFile, int dwFunc) {
        var mh$ = EscapeCommFunction$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EscapeCommFunction", hFile, dwFunc);
            }
            return (int) mh$.invokeExact(hFile, dwFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle GetCommMask$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("GetCommMask"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static int GetCommMask(MemorySegment hFile, MemorySegment lpEvtMask) {
        var mh$ = GetCommMask$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommMask", hFile, lpEvtMask);
            }
            return (int) mh$.invokeExact(hFile, lpEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle GetCommProperties$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("GetCommProperties"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static int GetCommProperties(MemorySegment hFile, MemorySegment lpCommProp) {
        var mh$ = GetCommProperties$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommProperties", hFile, lpCommProp);
            }
            return (int) mh$.invokeExact(hFile, lpCommProp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle GetCommModemStatus$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("GetCommModemStatus"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static int GetCommModemStatus(MemorySegment hFile, MemorySegment lpModemStat) {
        var mh$ = GetCommModemStatus$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommModemStatus", hFile, lpModemStat);
            }
            return (int) mh$.invokeExact(hFile, lpModemStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle GetCommState$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("GetCommState"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int GetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = GetCommState$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommState", hFile, lpDCB);
            }
            return (int) mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle GetCommTimeouts$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("GetCommTimeouts"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int GetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = GetCommTimeouts$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int) mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle SetCommMask$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_LONG
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("SetCommMask"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static int SetCommMask(MemorySegment hFile, int dwEvtMask) {
        var mh$ = SetCommMask$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommMask", hFile, dwEvtMask);
            }
            return (int) mh$.invokeExact(hFile, dwEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle SetCommState$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("SetCommState"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int SetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = SetCommState$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommState", hFile, lpDCB);
            }
            return (int) mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle SetCommTimeouts$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("SetCommTimeouts"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int SetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = SetCommTimeouts$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int) mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle WaitCommEvent$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_INT,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("WaitCommEvent"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WaitCommEvent(MemorySegment hFile, MemorySegment lpEvtMask, MemorySegment lpOverlapped) {
        var mh$ = WaitCommEvent$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitCommEvent", hFile, lpEvtMask, lpOverlapped);
            }
            return (int) mh$.invokeExact(hFile, lpEvtMask, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle FormatMessageA$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_LONG,
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("FormatMessageA"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static int FormatMessageA(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageA$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatMessageA", dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
            }
            return (int) mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle RegCloseKey$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_LONG,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("RegCloseKey"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static int RegCloseKey(MemorySegment hKey) {
        var mh$ = RegCloseKey$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCloseKey", hKey);
            }
            return (int) mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle RegEnumValueA$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("RegEnumValueA"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegEnumValueA(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueA$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumValueA", hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int) mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle RegOpenKeyExA$MH() {
        class Holder {
            static final FunctionDescriptor DESC = FunctionDescriptor.of(
                Windows.C_LONG,
                Windows.C_POINTER,
                Windows.C_POINTER,
                Windows.C_LONG,
                Windows.C_LONG,
                Windows.C_POINTER
            );

            static final MethodHandle MH = Linker.nativeLinker().downcallHandle(
                    Windows.findOrThrow("RegOpenKeyExA"),
                    DESC);
        }
        return Holder.MH;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExA$MH();
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyExA", hKey, lpSubKey, ulOptions, samDesired, phkResult);
            }
            return (int) mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);

    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int GENERIC_READ = (int)2147483648L;

    /**
     * {@snippet lang=c :
     * #define GENERIC_READ 2147483648
     * }
     */
    public static int GENERIC_READ() {
        return GENERIC_READ;
    }
    private static final int GENERIC_WRITE = (int)1073741824L;

    /**
     * {@snippet lang=c :
     * #define GENERIC_WRITE 1073741824
     * }
     */
    public static int GENERIC_WRITE() {
        return GENERIC_WRITE;
    }
    private static final int KEY_READ = (int)131097L;

    /**
     * {@snippet lang=c :
     * #define KEY_READ 131097
     * }
     */
    public static int KEY_READ() {
        return KEY_READ;
    }
    private static final MemorySegment INVALID_HANDLE_VALUE = MemorySegment.ofAddress(-1L);

    /**
     * {@snippet lang=c :
     * #define INVALID_HANDLE_VALUE (void*) -1
     * }
     */
    public static MemorySegment INVALID_HANDLE_VALUE() {
        return INVALID_HANDLE_VALUE;
    }
    private static final int WAIT_OBJECT_0 = (int)0L;

    /**
     * {@snippet lang=c :
     * #define WAIT_OBJECT_0 0
     * }
     */
    public static int WAIT_OBJECT_0() {
        return WAIT_OBJECT_0;
    }
    private static final int INFINITE = (int)4294967295L;

    /**
     * {@snippet lang=c :
     * #define INFINITE 4294967295
     * }
     */
    public static int INFINITE() {
        return INFINITE;
    }
    private static final int ERROR_SUCCESS = (int)0L;

    /**
     * {@snippet lang=c :
     * #define ERROR_SUCCESS 0
     * }
     */
    public static int ERROR_SUCCESS() {
        return ERROR_SUCCESS;
    }
    private static final int NO_ERROR = (int)0L;

    /**
     * {@snippet lang=c :
     * #define NO_ERROR 0
     * }
     */
    public static int NO_ERROR() {
        return NO_ERROR;
    }
    private static final int ERROR_FILE_NOT_FOUND = (int)2L;

    /**
     * {@snippet lang=c :
     * #define ERROR_FILE_NOT_FOUND 2
     * }
     */
    public static int ERROR_FILE_NOT_FOUND() {
        return ERROR_FILE_NOT_FOUND;
    }
    private static final int ERROR_PATH_NOT_FOUND = (int)3L;

    /**
     * {@snippet lang=c :
     * #define ERROR_PATH_NOT_FOUND 3
     * }
     */
    public static int ERROR_PATH_NOT_FOUND() {
        return ERROR_PATH_NOT_FOUND;
    }
    private static final int ERROR_NO_MORE_ITEMS = (int)259L;

    /**
     * {@snippet lang=c :
     * #define ERROR_NO_MORE_ITEMS 259
     * }
     */
    public static int ERROR_NO_MORE_ITEMS() {
        return ERROR_NO_MORE_ITEMS;
    }
    private static final int ERROR_IO_PENDING = (int)997L;

    /**
     * {@snippet lang=c :
     * #define ERROR_IO_PENDING 997
     * }
     */
    public static int ERROR_IO_PENDING() {
        return ERROR_IO_PENDING;
    }
    private static final MemorySegment HKEY_LOCAL_MACHINE = MemorySegment.ofAddress(-2147483646L);

    /**
     * {@snippet lang=c :
     * #define HKEY_LOCAL_MACHINE (void*) -2147483646
     * }
     */
    public static MemorySegment HKEY_LOCAL_MACHINE() {
        return HKEY_LOCAL_MACHINE;
    }
}

