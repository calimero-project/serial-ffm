// Generated by jextract

package org.win;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class Windows  {

    public static final OfByte C_CHAR = JAVA_BYTE;
    public static final OfShort C_SHORT = JAVA_SHORT;
    public static final OfInt C_INT = JAVA_INT;
    public static final OfInt C_LONG = JAVA_INT;
    public static final OfLong C_LONG_LONG = JAVA_LONG;
    public static final OfFloat C_FLOAT = JAVA_FLOAT;
    public static final OfDouble C_DOUBLE = JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = RuntimeHelper.POINTER;
    /**
     * {@snippet :
     * #define FALSE 0
     * }
     */
    public static int FALSE() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define TRUE 1
     * }
     */
    public static int TRUE() {
        return (int)1L;
    }
    /**
     * {@snippet :
     * #define FILE_ATTRIBUTE_NORMAL 128
     * }
     */
    public static int FILE_ATTRIBUTE_NORMAL() {
        return (int)128L;
    }
    /**
     * {@snippet :
     * #define OPEN_EXISTING 3
     * }
     */
    public static int OPEN_EXISTING() {
        return (int)3L;
    }
    /**
     * {@snippet :
     * #define FILE_FLAG_OVERLAPPED 1073741824
     * }
     */
    public static int FILE_FLAG_OVERLAPPED() {
        return (int)1073741824L;
    }
    /**
     * {@snippet :
     * #define DTR_CONTROL_DISABLE 0
     * }
     */
    public static int DTR_CONTROL_DISABLE() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define RTS_CONTROL_DISABLE 0
     * }
     */
    public static int RTS_CONTROL_DISABLE() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define RTS_CONTROL_HANDSHAKE 2
     * }
     */
    public static int RTS_CONTROL_HANDSHAKE() {
        return (int)2L;
    }
    /**
     * {@snippet :
     * #define FILE_TYPE_UNKNOWN 0
     * }
     */
    public static int FILE_TYPE_UNKNOWN() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define FILE_TYPE_CHAR 2
     * }
     */
    public static int FILE_TYPE_CHAR() {
        return (int)2L;
    }
    /**
     * {@snippet :
     * #define NOPARITY 0
     * }
     */
    public static int NOPARITY() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define ONESTOPBIT 0
     * }
     */
    public static int ONESTOPBIT() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define TWOSTOPBITS 2
     * }
     */
    public static int TWOSTOPBITS() {
        return (int)2L;
    }
    /**
     * {@snippet :
     * #define CE_RXOVER 1
     * }
     */
    public static int CE_RXOVER() {
        return (int)1L;
    }
    /**
     * {@snippet :
     * #define CE_OVERRUN 2
     * }
     */
    public static int CE_OVERRUN() {
        return (int)2L;
    }
    /**
     * {@snippet :
     * #define CE_RXPARITY 4
     * }
     */
    public static int CE_RXPARITY() {
        return (int)4L;
    }
    /**
     * {@snippet :
     * #define CE_FRAME 8
     * }
     */
    public static int CE_FRAME() {
        return (int)8L;
    }
    /**
     * {@snippet :
     * #define CE_BREAK 16
     * }
     */
    public static int CE_BREAK() {
        return (int)16L;
    }
    /**
     * {@snippet :
     * #define EV_RXCHAR 1
     * }
     */
    public static int EV_RXCHAR() {
        return (int)1L;
    }
    /**
     * {@snippet :
     * #define EV_RXFLAG 2
     * }
     */
    public static int EV_RXFLAG() {
        return (int)2L;
    }
    /**
     * {@snippet :
     * #define EV_CTS 8
     * }
     */
    public static int EV_CTS() {
        return (int)8L;
    }
    /**
     * {@snippet :
     * #define EV_DSR 16
     * }
     */
    public static int EV_DSR() {
        return (int)16L;
    }
    /**
     * {@snippet :
     * #define EV_RLSD 32
     * }
     */
    public static int EV_RLSD() {
        return (int)32L;
    }
    /**
     * {@snippet :
     * #define EV_BREAK 64
     * }
     */
    public static int EV_BREAK() {
        return (int)64L;
    }
    /**
     * {@snippet :
     * #define EV_ERR 128
     * }
     */
    public static int EV_ERR() {
        return (int)128L;
    }
    /**
     * {@snippet :
     * #define EV_RING 256
     * }
     */
    public static int EV_RING() {
        return (int)256L;
    }
    /**
     * {@snippet :
     * #define SETDTR 5
     * }
     */
    public static int SETDTR() {
        return (int)5L;
    }
    /**
     * {@snippet :
     * #define FORMAT_MESSAGE_IGNORE_INSERTS 512
     * }
     */
    public static int FORMAT_MESSAGE_IGNORE_INSERTS() {
        return (int)512L;
    }
    /**
     * {@snippet :
     * #define FORMAT_MESSAGE_FROM_SYSTEM 4096
     * }
     */
    public static int FORMAT_MESSAGE_FROM_SYSTEM() {
        return (int)4096L;
    }
    /**
     * {@snippet :
     * #define FORMAT_MESSAGE_MAX_WIDTH_MASK 255
     * }
     */
    public static int FORMAT_MESSAGE_MAX_WIDTH_MASK() {
        return (int)255L;
    }
    public static MethodHandle CreateFileA$MH() {
        return RuntimeHelper.requireNonNull(constants$1.const$4,"CreateFileA");
    }
    /**
     * {@snippet :
     * void* CreateFileA(char* lpFileName, unsigned long dwDesiredAccess, unsigned long dwShareMode, struct _SECURITY_ATTRIBUTES* lpSecurityAttributes, unsigned long dwCreationDisposition, unsigned long dwFlagsAndAttributes, void* hTemplateFile);
     * }
     */
    public static MemorySegment CreateFileA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileA$MH();
        try {
            return (java.lang.foreign.MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle FlushFileBuffers$MH() {
        return RuntimeHelper.requireNonNull(constants$1.const$6,"FlushFileBuffers");
    }
    /**
     * {@snippet :
     * int FlushFileBuffers(void* hFile);
     * }
     */
    public static int FlushFileBuffers(MemorySegment hFile) {
        var mh$ = FlushFileBuffers$MH();
        try {
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetFileType$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$0,"GetFileType");
    }
    /**
     * {@snippet :
     * unsigned long GetFileType(void* hFile);
     * }
     */
    public static int GetFileType(MemorySegment hFile) {
        var mh$ = GetFileType$MH();
        try {
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ReadFile$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$2,"ReadFile");
    }
    /**
     * {@snippet :
     * int ReadFile(void* hFile, void* lpBuffer, unsigned long nNumberOfBytesToRead, unsigned long* lpNumberOfBytesRead, struct _OVERLAPPED* lpOverlapped);
     * }
     */
    public static int ReadFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, MemorySegment lpOverlapped) {
        var mh$ = ReadFile$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WriteFile$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$3,"WriteFile");
    }
    /**
     * {@snippet :
     * int WriteFile(void* hFile, void* lpBuffer, unsigned long nNumberOfBytesToWrite, unsigned long* lpNumberOfBytesWritten, struct _OVERLAPPED* lpOverlapped);
     * }
     */
    public static int WriteFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, MemorySegment lpOverlapped) {
        var mh$ = WriteFile$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CloseHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$4,"CloseHandle");
    }
    /**
     * {@snippet :
     * int CloseHandle(void* hObject);
     * }
     */
    public static int CloseHandle(MemorySegment hObject) {
        var mh$ = CloseHandle$MH();
        try {
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetLastError$MH() {
        return RuntimeHelper.requireNonNull(constants$2.const$6,"GetLastError");
    }
    /**
     * {@snippet :
     * unsigned long GetLastError();
     * }
     */
    public static int GetLastError() {
        var mh$ = GetLastError$MH();
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetOverlappedResult$MH() {
        return RuntimeHelper.requireNonNull(constants$3.const$1,"GetOverlappedResult");
    }
    /**
     * {@snippet :
     * int GetOverlappedResult(void* hFile, struct _OVERLAPPED* lpOverlapped, unsigned long* lpNumberOfBytesTransferred, int bWait);
     * }
     */
    public static int GetOverlappedResult(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int bWait) {
        var mh$ = GetOverlappedResult$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WaitForSingleObject$MH() {
        return RuntimeHelper.requireNonNull(constants$3.const$3,"WaitForSingleObject");
    }
    /**
     * {@snippet :
     * unsigned long WaitForSingleObject(void* hHandle, unsigned long dwMilliseconds);
     * }
     */
    public static int WaitForSingleObject(MemorySegment hHandle, int dwMilliseconds) {
        var mh$ = WaitForSingleObject$MH();
        try {
            return (int)mh$.invokeExact(hHandle, dwMilliseconds);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CreateEventA$MH() {
        return RuntimeHelper.requireNonNull(constants$3.const$5,"CreateEventA");
    }
    /**
     * {@snippet :
     * void* CreateEventA(struct _SECURITY_ATTRIBUTES* lpEventAttributes, int bManualReset, int bInitialState, char* lpName);
     * }
     */
    public static MemorySegment CreateEventA(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventA$MH();
        try {
            return (java.lang.foreign.MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle ClearCommError$MH() {
        return RuntimeHelper.requireNonNull(constants$11.const$1,"ClearCommError");
    }
    /**
     * {@snippet :
     * int ClearCommError(void* hFile, unsigned long* lpErrors, struct _COMSTAT* lpStat);
     * }
     */
    public static int ClearCommError(MemorySegment hFile, MemorySegment lpErrors, MemorySegment lpStat) {
        var mh$ = ClearCommError$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpErrors, lpStat);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetupComm$MH() {
        return RuntimeHelper.requireNonNull(constants$11.const$3,"SetupComm");
    }
    /**
     * {@snippet :
     * int SetupComm(void* hFile, unsigned long dwInQueue, unsigned long dwOutQueue);
     * }
     */
    public static int SetupComm(MemorySegment hFile, int dwInQueue, int dwOutQueue) {
        var mh$ = SetupComm$MH();
        try {
            return (int)mh$.invokeExact(hFile, dwInQueue, dwOutQueue);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle EscapeCommFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$11.const$4,"EscapeCommFunction");
    }
    /**
     * {@snippet :
     * int EscapeCommFunction(void* hFile, unsigned long dwFunc);
     * }
     */
    public static int EscapeCommFunction(MemorySegment hFile, int dwFunc) {
        var mh$ = EscapeCommFunction$MH();
        try {
            return (int)mh$.invokeExact(hFile, dwFunc);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetCommMask$MH() {
        return RuntimeHelper.requireNonNull(constants$11.const$6,"GetCommMask");
    }
    /**
     * {@snippet :
     * int GetCommMask(void* hFile, unsigned long* lpEvtMask);
     * }
     */
    public static int GetCommMask(MemorySegment hFile, MemorySegment lpEvtMask) {
        var mh$ = GetCommMask$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpEvtMask);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetCommProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$12.const$0,"GetCommProperties");
    }
    /**
     * {@snippet :
     * int GetCommProperties(void* hFile, struct _COMMPROP* lpCommProp);
     * }
     */
    public static int GetCommProperties(MemorySegment hFile, MemorySegment lpCommProp) {
        var mh$ = GetCommProperties$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpCommProp);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetCommModemStatus$MH() {
        return RuntimeHelper.requireNonNull(constants$12.const$1,"GetCommModemStatus");
    }
    /**
     * {@snippet :
     * int GetCommModemStatus(void* hFile, unsigned long* lpModemStat);
     * }
     */
    public static int GetCommModemStatus(MemorySegment hFile, MemorySegment lpModemStat) {
        var mh$ = GetCommModemStatus$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpModemStat);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetCommState$MH() {
        return RuntimeHelper.requireNonNull(constants$12.const$2,"GetCommState");
    }
    /**
     * {@snippet :
     * int GetCommState(void* hFile, struct _DCB* lpDCB);
     * }
     */
    public static int GetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = GetCommState$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetCommTimeouts$MH() {
        return RuntimeHelper.requireNonNull(constants$12.const$3,"GetCommTimeouts");
    }
    /**
     * {@snippet :
     * int GetCommTimeouts(void* hFile, struct _COMMTIMEOUTS* lpCommTimeouts);
     * }
     */
    public static int GetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = GetCommTimeouts$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetCommMask$MH() {
        return RuntimeHelper.requireNonNull(constants$12.const$4,"SetCommMask");
    }
    /**
     * {@snippet :
     * int SetCommMask(void* hFile, unsigned long dwEvtMask);
     * }
     */
    public static int SetCommMask(MemorySegment hFile, int dwEvtMask) {
        var mh$ = SetCommMask$MH();
        try {
            return (int)mh$.invokeExact(hFile, dwEvtMask);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetCommState$MH() {
        return RuntimeHelper.requireNonNull(constants$12.const$5,"SetCommState");
    }
    /**
     * {@snippet :
     * int SetCommState(void* hFile, struct _DCB* lpDCB);
     * }
     */
    public static int SetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = SetCommState$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetCommTimeouts$MH() {
        return RuntimeHelper.requireNonNull(constants$13.const$0,"SetCommTimeouts");
    }
    /**
     * {@snippet :
     * int SetCommTimeouts(void* hFile, struct _COMMTIMEOUTS* lpCommTimeouts);
     * }
     */
    public static int SetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = SetCommTimeouts$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WaitCommEvent$MH() {
        return RuntimeHelper.requireNonNull(constants$13.const$1,"WaitCommEvent");
    }
    /**
     * {@snippet :
     * int WaitCommEvent(void* hFile, unsigned long* lpEvtMask, struct _OVERLAPPED* lpOverlapped);
     * }
     */
    public static int WaitCommEvent(MemorySegment hFile, MemorySegment lpEvtMask, MemorySegment lpOverlapped) {
        var mh$ = WaitCommEvent$MH();
        try {
            return (int)mh$.invokeExact(hFile, lpEvtMask, lpOverlapped);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle FormatMessageA$MH() {
        return RuntimeHelper.requireNonNull(constants$13.const$3,"FormatMessageA");
    }
    /**
     * {@snippet :
     * unsigned long FormatMessageA(unsigned long dwFlags, void* lpSource, unsigned long dwMessageId, unsigned long dwLanguageId, char* lpBuffer, unsigned long nSize, char** Arguments);
     * }
     */
    public static int FormatMessageA(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageA$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle RegCloseKey$MH() {
        return RuntimeHelper.requireNonNull(constants$13.const$4,"RegCloseKey");
    }
    /**
     * {@snippet :
     * long RegCloseKey(struct HKEY__* hKey);
     * }
     */
    public static int RegCloseKey(MemorySegment hKey) {
        var mh$ = RegCloseKey$MH();
        try {
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle RegEnumValueA$MH() {
        return RuntimeHelper.requireNonNull(constants$13.const$6,"RegEnumValueA");
    }
    /**
     * {@snippet :
     * long RegEnumValueA(struct HKEY__* hKey, unsigned long dwIndex, char* lpValueName, unsigned long* lpcchValueName, unsigned long* lpReserved, unsigned long* lpType, unsigned char* lpData, unsigned long* lpcbData);
     * }
     */
    public static int RegEnumValueA(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueA$MH();
        try {
            return (int)mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle RegOpenKeyExA$MH() {
        return RuntimeHelper.requireNonNull(constants$14.const$1,"RegOpenKeyExA");
    }
    /**
     * {@snippet :
     * long RegOpenKeyExA(struct HKEY__* hKey, char* lpSubKey, unsigned long ulOptions, unsigned long samDesired, struct HKEY__** phkResult);
     * }
     */
    public static int RegOpenKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExA$MH();
        try {
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet :
     * #define NULL 0
     * }
     */
    public static MemorySegment NULL() {
        return constants$14.const$2;
    }
    /**
     * {@snippet :
     * #define GENERIC_READ 2147483648
     * }
     */
    public static int GENERIC_READ() {
        return (int)2147483648L;
    }
    /**
     * {@snippet :
     * #define GENERIC_WRITE 1073741824
     * }
     */
    public static int GENERIC_WRITE() {
        return (int)1073741824L;
    }
    /**
     * {@snippet :
     * #define KEY_READ 131097
     * }
     */
    public static int KEY_READ() {
        return (int)131097L;
    }
    /**
     * {@snippet :
     * #define INVALID_HANDLE_VALUE -1
     * }
     */
    public static MemorySegment INVALID_HANDLE_VALUE() {
        return constants$14.const$3;
    }
    /**
     * {@snippet :
     * #define WAIT_OBJECT_0 0
     * }
     */
    public static int WAIT_OBJECT_0() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define INFINITE 4294967295
     * }
     */
    public static int INFINITE() {
        return (int)4294967295L;
    }
    /**
     * {@snippet :
     * #define ERROR_SUCCESS 0
     * }
     */
    public static int ERROR_SUCCESS() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define NO_ERROR 0
     * }
     */
    public static int NO_ERROR() {
        return (int)0L;
    }
    /**
     * {@snippet :
     * #define ERROR_FILE_NOT_FOUND 2
     * }
     */
    public static int ERROR_FILE_NOT_FOUND() {
        return (int)2L;
    }
    /**
     * {@snippet :
     * #define ERROR_PATH_NOT_FOUND 3
     * }
     */
    public static int ERROR_PATH_NOT_FOUND() {
        return (int)3L;
    }
    /**
     * {@snippet :
     * #define ERROR_NO_MORE_ITEMS 259
     * }
     */
    public static int ERROR_NO_MORE_ITEMS() {
        return (int)259L;
    }
    /**
     * {@snippet :
     * #define ERROR_IO_PENDING 997
     * }
     */
    public static int ERROR_IO_PENDING() {
        return (int)997L;
    }
    /**
     * {@snippet :
     * #define HKEY_LOCAL_MACHINE -2147483646
     * }
     */
    public static MemorySegment HKEY_LOCAL_MACHINE() {
        return constants$14.const$4;
    }
}


